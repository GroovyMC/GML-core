plugins {
    id 'groovy'
    id 'maven-publish'
    id 'org.cadixdev.licenser' version '0.6.1'
    id 'net.minecraftforge.gradle' version '5.1.+'
    id 'org.parchmentmc.librarian.forgegradle' version '1.+'
    id 'com.github.johnrengelman.shadow' version '7.1.2' apply false
    id 'io.github.groovymc.modsdotgroovy' version '1.0.2'
}

modsDotGroovy {
    dslVersion = '1.0.2' // Can be replaced with any existing DSL version
}

// Mojang ships Java 17 to end users in 1.18+, so your mod should target Java 17.
java.toolchain.languageVersion = JavaLanguageVersion.of(17)

println "Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}"

minecraft {
    mappings channel: 'parchment', version: '1.18.2-2022.07.17-1.19'
}

configurations {
    globalCompile
    compileOnly.extendsFrom(globalCompile)
    transformCompileOnly.extendsFrom(globalCompile)
    testCompileOnly.extendsFrom(globalCompile)

    globalAP
    annotationProcessor.extendsFrom(globalAP)
    transformAnnotationProcessor.extendsFrom(globalAP)
    testAnnotationProcessor.extendsFrom(globalAP)

    groovy
    globalCompile.extendsFrom(groovy)

    runtimeOnly.extendsFrom(groovy)
}

sourceSets {
    transform {
        compileClasspath += configurations.getByName('minecraft')
    }

    test {
        compileClasspath += transform.output
    }
}
tasks.create('groovyJar', ManifestTransformingJiJ)

// GML is written in pure Groovy, so delete the empty java folder in each of the sourceSets
sourceSets.each { sourceSet ->
    final javaDir = file("src/${sourceSet.name}/java/")
    javaDir.deleteDir()
}

repositories {
    maven {
        name = 'Modding Inquisition Snapshots'
        url = 'https://maven.moddinginquisition.org/snapshots'
    }
}

final groovyLibs = [
        'stdlib', 'contracts', 'datetime',
        'nio', 'macro', 'macro-library',
        'templates', 'typecheckers',

        'dateutil', 'ginq',

        'toml', 'json'
]

dependencies {
    minecraft "net.minecraftforge:forge:${mc_version}-${forge_version}"

    groovyLibs.each {
        groovy groovyDep(it)
        groovyJar.setRange(groovyId(it), "[${groovy_version},${groovy_next_major})")
    }

    transformCompileOnly sourceSets.main.output

    testCompileOnly sourceSets.main.output
    testCompileOnly modsDotGroovy.mdgDsl()
}

String groovyDep(String name) {
    return "${groovyId(name)}:${project.groovy_version}"
}

static String groovyId(String name) {
    return "org.apache.groovy:groovy${name == 'stdlib' ? '' : '-' + name}"
}

tasks.withType(GroovyCompile).configureEach { GroovyCompile task ->
    task.groovyOptions.fork = true
    task.groovyOptions.encoding = 'UTF-8'
    task.groovyOptions.optimizationOptions.indy = true
}
compileGroovy.groovyOptions.optimizationOptions.groovydoc = true

license {
    header = rootProject.file('LICENSE')
}

final manifestAttr = [
        'Specification-Title': 'GroovyModLoader',
        'Specification-Vendor': 'GroovyMC',
        'Specification-Version': 1,
        'Implementation-Title': project.name,
        'Implementation-Version': project.version,
        'Implementation-Vendor' : 'GroovyMC',
        'Implementation-Timestamp': new Date().format(/yyyy-MM-dd'T'HH:mm:ssZ/),
        'GitCommit': getGitCommit(),
        'FMLModType' : 'LANGPROVIDER',
]

tasks.create('testJar', Jar) {
    group 'build'
    from sourceSets.test.output
    classifier 'test'
    manifest.attributes([
            'Specification-Title': 'no',
            'Specification-Vendor': 'Paint_Ninja',
            'Specification-Version': '1',
            'Implementation-Title': 'test',
            'Implementation-Version': '12.12',
            'Implementation-Vendor': 'Paint_Ninja',
            'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
    ])
}

tasks.named('groovyJar', ManifestTransformingJiJ).configure {
    group('build')
    output.set(project.file("$buildDir/libs/${archivesBaseName}-${version}-groovy.jar"))
    configurations = [project.configurations.groovy]
    manifestAttributes.set(manifestAttr + [
            'Specification-Title': 'GML-GroovyFatJar',
            'Automatic-Module-Name': 'com.matyrobbrt.gml.groovyjij'
    ])

    [
            'jackson-databind', 'jackson-core', 'jackson-annotations'
    ].each {
        setUpperBound('com.fasterxml.jackson.core:' + it, '3.0.0')
    }
    setUpperBound('com.fasterxml.jackson.dataformat:jackson-dataformat-toml', '3.0.0')
}

tasks.create('fullJar', Jar) {
    from sourceSets.main.output
    from sourceSets.transform.output
    manifest.attributes(manifestAttr + [
            'Automatic-Module-Name': 'com.matyrobbrt.gml', 'FMLModType': 'LANGPROVIDER'
    ])
    archiveClassifier.set 'full'
    group 'build'
    dependsOn(groovyJar)
    final File groovyOut = groovyJar.output.get().asFile
    from(groovyOut) {
        into 'META-INF/jarjar'
        rename groovyOut.name, 'groovy.jar'
    }
    final path = project.file("$buildDir/jarjar/metadata.json")
    doFirst {
        makeJarJar(path)
    }
    from(path) {
        into 'META-INF/jarjar'
    }
}

tasks.create('transformJar', Jar) {
    from sourceSets.transform.output
    manifest.attributes(manifestAttr)
    archiveClassifier.set 'transform'
    group 'build'
}

private void makeJarJar(File path) {
    final groovy = JiJUtils.makeJarJson('com.matyrobbrt.gml', 'groovy-fat', project.groovy_version, 'groovy.jar',
        "[$groovy_version,$groovy_next_major)")
    JiJUtils.writeJiJ(path, groovy)
}

static String getGitCommit() {
    def proc = 'git rev-parse --short HEAD'.execute()
    proc.waitFor()
    return proc.exitValue()? "ERROR(${proc.exitValue()})" : proc.text.trim()
}