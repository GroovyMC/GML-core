import com.matyrobbrt.gradle.jarinjar.task.*
import com.matyrobbrt.gradle.jarinjar.transform.ForgeManifestFixerTransformer
import groovy.transform.CompileStatic
import org.groovymc.modsdotgroovy.gradle.MDGExtension
import org.w3c.dom.Document
import org.w3c.dom.Element

plugins {
    id 'java-library'
    id 'eclipse'
    id 'idea'
    id 'groovy'
    id 'signing'
    id 'maven-publish'
    id 'com.matyrobbrt.jarinjar' version '1.2.0'
    id 'net.neoforged.gradle.userdev' version '7.0.80'
    id 'org.groovymc.modsdotgroovy' version '2.0.0-beta.10'
    id 'io.github.gradle-nexus.publish-plugin' version '2.0.0-rc-1'
    id 'dev.lukebemish.managedversioning' version '1.2.7'
}

group = 'org.groovymc.gml'

base {
    archivesName = 'gml-core'
}

managedVersioning {
    versionFile.set rootProject.file('version.properties')

    gitHubActions {
        release {
            prettyName.set 'Release'
            workflowDispatch.set(true)
            gradleJob {
                name.set 'build'
                step {
                    setupGitUser()
                }
                readOnly.set false
                gradlew 'Tag Release', 'tagRelease'
                gradlew 'Build', 'build'
                gradlew 'Publish', 'publish', 'closeAndReleaseSonatypeStagingRepository'
                step {
                    run.set 'git push && git push --tags'
                }
                secret('CENTRAL_MAVEN_USER')
                secret('CENTRAL_MAVEN_PASSWORD')
                secret('GPG_SIGNING_KEY')
                secret('GPG_KEY_PASSWORD')
            }
        }
    }
}

managedVersioning.apply()

println "Building: $version"

// Mojang ships Java 17 to end users in 1.18+, so your mod should target Java 17.
java.toolchain.languageVersion = JavaLanguageVersion.of(17)

sourceSets {
    register('transform')
    register('extension')
}

repositories {
    mavenLocal()
}

sourceSets.main.extensions.getByType(MDGExtension).disable()
sourceSets.test.extensions.getByType(MDGExtension).enable()

configurations {
    groovy
    compileOnly.extendsFrom(groovy)
    testCompileOnly.extendsFrom(groovy)
    extensionCompileOnly.extendsFrom(groovy)
    transformCompileOnly.extendsFrom(groovy)

    final mc = create('minecraft')
    implementation.extendsFrom(mc)
    extensionCompileOnly.extendsFrom(mc)
    transformCompileOnly.extendsFrom(mc)
}

tasks.register('fullJar', ForgeJarInJarTask)

// Default run configurations.
// These can be tweaked, removed, or duplicated as needed.
runs {
    // applies to all the run configs below
    configureEach {
        // Recommended logging data for a userdev environment
        // The markers can be added/remove as needed separated by commas.
        // "SCAN": For mods scan.
        // "REGISTRIES": For firing of registry events.
        // "REGISTRYDUMP": For getting the contents of all registries.
        systemProperty 'forge.logging.markers', 'REGISTRIES'

        // Recommended logging level for the console
        // You can set various levels here.
        // Please read: https://stackoverflow.com/questions/2031163/when-to-use-the-different-log-levels
        systemProperty 'forge.logging.console.level', 'debug'

        modSource project.sourceSets.test
    }

    client {
    }

    server {
        programArgument '--nogui'
    }
}

final groovyLibs = [
        'stdlib', 'contracts', 'datetime',
        'nio', 'macro', 'macro-library',
        'templates', 'typecheckers',

        'dateutil', 'ginq',

        'toml', 'json'
]

dependencies {
    minecraft "net.neoforged:neoforge:20.4.167"

    transformCompileOnly(sourceSets.main.output)
    compileOnly(testCompileOnly(sourceSets.extension.output))
    testCompileOnly(sourceSets.transform.output)

    groovyLibs.each {
        groovy groovyDep(it as String)
    }
    
    runtimeOnly(files(project.tasks.fullJar.archiveFile))
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

String groovyDep(final String name) {
    return "${groovyId(name)}:${project.groovy_version}"
}

static String groovyId(final String name) {
    return "org.apache.groovy:groovy${name == 'stdlib' ? '' : '-' + name}"
}

jij.onConfiguration('groovy') {
    final manifestFix = new ForgeManifestFixerTransformer(modType: 'LIBRARY', modulePrefix: 'org.groovymc.gml.groovyjij')
    eachMatching('.+') {
        versionRange nextMajor
        transform manifestFix
    }
}

final manifestAttr = [
        'Specification-Title'   : 'GroovyModLoader',
        'Specification-Vendor'  : 'GroovyMC',
        'Specification-Version' : 1,
        'Implementation-Title'  : project.name,
        'Implementation-Version': project.version,
        'Implementation-Vendor' : 'GroovyMC',
        'BundledGroovyVersion'  : project.groovy_version,
        'GitCommit'             : getGitCommit(),
        'FMLModType'            : 'LIBRARY'
]

tasks.named('jar', Jar).configure {
    from sourceSets.extension.output
    manifest.attributes(manifestAttr + [
            'Automatic-Module-Name': 'org.groovymc.gml'
    ])
}

final transformDest = new File(buildDir, 'libs/transform')
tasks.register('transformJar', Jar) {
    from sourceSets.transform.output
    manifest.attributes(manifestAttr + [
            'Specification-Title': 'GML-Transform'
    ])
    archiveBaseName.set('transform')
    destinationDirectory.set(transformDest)
}

tasks.register('transformSources', Jar) {
    from sourceSets.transform.allSource
    archiveBaseName.set('transform')
    archiveClassifier.set('sources')
    destinationDirectory.set(transformDest)
}

tasks.register('transformGroovydoc', Groovydoc) {
    source sourceSets.transform.allSource
    classpath = sourceSets.main.compileClasspath
    destinationDir = new File(transformDest, 'groovydoc')
}

tasks.register('transformJavadocJar', Jar) {
    archiveClassifier = 'javadoc'
    from tasks.transformGroovydoc.destinationDir
    dependsOn('transformGroovydoc')
    destinationDirectory.set(transformDest)
}

tasks.register('groovyJar', ForgeJarInJarTask) {
    group('build')
    archiveBaseName.set('groovy-fat')
    fromConfiguration(project.configurations.groovy)
    manifest.attributes(manifestAttr + [
            'Specification-Title': 'GML-GroovyFatJar',
            'Automatic-Module-Name': 'org.groovymc.gml.groovyjij'
    ])
}

tasks.named('fullJar', ForgeJarInJarTask).configure {
    from(sourceSets.main.output)
    from(sourceSets.transform.output)
    from(sourceSets.extension.output)
    manifest.attributes(manifestAttr + [
            'Automatic-Module-Name': 'org.groovymc.gml'
    ])
    archiveClassifier.set('all')
    group('build')

    fromJar(tasks.named('groovyJar')) { versionRange nextMajor }

    tasks.build.dependsOn(it)
}

tasks.runClient.dependsOn(tasks.fullJar)

project(':script-mods').afterEvaluate {
    rootProject.tasks.named('fullJar', ForgeJarInJarTask) {
        fromJar(project(':script-mods').tasks.shadowJar as org.gradle.jvm.tasks.Jar) { versionRange nextMajor }
    }
}

tasks.withType(GroovyCompile).configureEach { GroovyCompile task ->
    task.groovyOptions.fork = true
    task.groovyOptions.encoding = 'UTF-8'
    task.groovyOptions.optimizationOptions.indy = true
}

java.withSourcesJar()
java.withJavadocJar()

groovydoc {
    use = true
}

tasks.register('groovydocJar', Jar) {
    archiveClassifier = 'javadoc'
    from groovydoc.destinationDir
    dependsOn(groovydoc)
}

static String getGitCommit() {
    final proc = 'git rev-parse --short HEAD'.execute()
    proc.waitFor()
    return proc.exitValue() ? "ERROR(${proc.exitValue()})" : proc.text.trim()
}

void sharedMetadata(MavenPom it) {
    it.packaging = 'jar'
    it.url = 'https://github.com/GroovyMC/GroovyModLoader'
    it.inceptionYear = '2022'
    it.licenses {
        license {
            name = 'MIT'
            url = 'https://opensource.org/license/mit/'
        }
    }
    it.developers {
        developer {
            id = 'groovymc'
            name = 'GroovyMC'
            email = 'holdings@groovymc.org'
            url = 'https://github.com/GroovyMC/'
        }
    }
    it.scm {
        connection='scm:git:git://github.com/GroovyMC/GroovyModLoader.git'
        url='https://github.com/GroovyMC/GroovyModLoader'
    }
}

nexusPublishing {
    repositories {
        sonatype {
            username.set(System.getenv('CENTRAL_MAVEN_USER') ?: '')
            password.set(System.getenv('CENTRAL_MAVEN_PASSWORD') ?: '')
            nexusUrl.set(uri("https://s01.oss.sonatype.org/service/local/"))
        }
    }
}

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            it.artifacts = [
                    jar, sourcesJar, fullJar, groovydocJar
            ]
            it.artifactId = 'gml-core'

            pom {
                name = 'GML'
                description = 'A language provider for Forge mods for Groovy'
                sharedMetadata(it)
                withXml { XmlProvider xml ->
                    final element = xml.asElement()
                    var depsElem = element.getOwnerDocument().createElement('dependencies')
                    var owner = element.getOwnerDocument()
                    var deps = (DependencySet) project.configurations.groovy.getDependencies()
                    deps.each {
                        depsElem.appendChild createDependency(owner, it.group, it.name, it.version, 'compile')
                    }
                    depsElem.appendChild createDependency(owner, project.group, 'transform', project.version, 'compile')
                    element.appendChild(depsElem)
                }
            }
        }
        register('transform', MavenPublication) {
            it.artifactId = 'transform'
            it.artifacts = [transformJar, transformSources, transformJavadocJar]
            pom {
                name = 'GML - Transform'
                description = 'Compile-time transforms for GML'
                sharedMetadata(it)
                withXml { XmlProvider xml ->
                    final element = xml.asElement()
                    var depsElem = element.getOwnerDocument().createElement('dependencies')
                    var owner = element.getOwnerDocument()
                    var deps = (DependencySet) project.configurations.groovy.getDependencies()
                    deps.each {
                        depsElem.appendChild createDependency(owner, it.group, it.name, it.version, 'compile')
                    }
                    element.appendChild(depsElem)
                }
            }
        }
    }
    repositories {
        maven {
            name 'repo'
            url file('repo')
        }
    }
}

if (System.getenv('GPG_SIGNING_KEY')) {
    signing {
        final signingKey = System.getenv('GPG_SIGNING_KEY') ?: ''
        final signingPassword = System.getenv('GPG_KEY_PASSWORD') ?: ''
        useInMemoryPgpKeys(signingKey, signingPassword)
        sign publishing.publications.mavenJava
        sign publishing.publications.transform
    }
}

@CompileStatic
static Element createDependency(Document owner, String group, String name, String version, String scope) {
    var sub = owner.createElement('dependency')

    var groupEl = owner.createElement('groupId')
    groupEl.appendChild(owner.createTextNode(group))
    sub.appendChild groupEl

    var artEl = owner.createElement('artifactId')
    artEl.appendChild(owner.createTextNode(name))
    sub.appendChild artEl

    var verEl = owner.createElement('version')
    verEl.appendChild(owner.createTextNode(version))
    sub.appendChild verEl

    var scopeEl = owner.createElement('scope')
    scopeEl.appendChild(owner.createTextNode(scope))
    sub.appendChild scopeEl

    return sub
}
