plugins {
    id 'groovy'
    id 'maven-publish'
    id 'org.cadixdev.licenser' version '0.6.1'
    id 'net.minecraftforge.gradle' version '5.1.+'
    id 'org.parchmentmc.librarian.forgegradle' version '1.+'
    id 'com.github.johnrengelman.shadow' version '7.1.2' apply false
}

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import com.github.jengelman.gradle.plugins.shadow.transformers.Transformer
import com.github.jengelman.gradle.plugins.shadow.transformers.TransformerContext
import shadow.org.apache.tools.zip.*
import shadow.org.codehaus.plexus.util.IOUtil

class UpdatedGroovyExtensionModuleTransformer implements Transformer {

    private static final GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH =
            'META-INF/groovy/org.codehaus.groovy.runtime.ExtensionModule'

    private static final MODULE_NAME_KEY = 'moduleName'
    private static final MODULE_VERSION_KEY = 'moduleVersion'
    private static final EXTENSION_CLASSES_KEY = 'extensionClasses'
    private static final STATIC_EXTENSION_CLASSES_KEY = 'staticExtensionClasses'

    private static final MERGED_MODULE_NAME = 'MergedByShadowJar'
    private static final MERGED_MODULE_VERSION = '1.0.0'

    private final Properties module = new Properties()

    @Override
    boolean canTransformResource(FileTreeElement element) {
        return element.relativePath.pathString == GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH
    }

    @Override
    void transform(TransformerContext context) {
        def props = new Properties()
        props.load(context.is)
        props.each { String key, String value ->
            switch (key) {
                case MODULE_NAME_KEY:
                    handle(key, value) {
                        module.setProperty(key, MERGED_MODULE_NAME)
                    }
                    break
                case MODULE_VERSION_KEY:
                    handle(key, value) {
                        module.setProperty(key, MERGED_MODULE_VERSION)
                    }
                    break
                case [EXTENSION_CLASSES_KEY, STATIC_EXTENSION_CLASSES_KEY]:
                    handle(key, value) { String existingValue ->
                        def newValue = "${existingValue},${value}"
                        module.setProperty(key, newValue)
                    }
                    break
            }
        }
    }

    private handle(String key, String value, Closure mergeValue) {
        def existingValue = module.getProperty(key)
        if (existingValue) {
            mergeValue(existingValue)
        } else {
            module.setProperty(key, value)
        }
    }

    @Override
    boolean hasTransformedResource() {
        return module.size() > 0
    }

    @Override
    void modifyOutputStream(ZipOutputStream os, boolean preserveFileTimestamps) {
        ZipEntry entry = new ZipEntry(GROOVY_EXTENSION_MODULE_DESCRIPTOR_PATH)
        entry.time = TransformerContext.getEntryTimestamp(preserveFileTimestamps, entry.time)
        os.putNextEntry(entry)
        IOUtil.copy(toInputStream(module), os)
        os.closeEntry()
    }

    private static InputStream toInputStream(Properties props) {
        def baos = new ByteArrayOutputStream()
        props.store(baos, null)
        return new ByteArrayInputStream(baos.toByteArray())
    }
}

// Mojang ships Java 17 to end users in 1.18+, so your mod should target Java 17.
java.toolchain.languageVersion = JavaLanguageVersion.of(17)

println "Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}"

minecraft {
    mappings channel: 'parchment', version: '1.18.2-2022.07.17-1.19'
}

configurations {
    globalCompile
    compileOnly.extendsFrom(globalCompile)
    transformCompileOnly.extendsFrom(globalCompile)
    testCompileOnly.extendsFrom(globalCompile)

    globalAP
    annotationProcessor.extendsFrom(globalAP)
    transformAnnotationProcessor.extendsFrom(globalAP)
    testAnnotationProcessor.extendsFrom(globalAP)

    groovy
    globalCompile.extendsFrom(groovy)
}

sourceSets {
    transform {
        compileClasspath += configurations.getByName('minecraft')
    }

    test {
        compileClasspath += transform.output
    }
}

// Groovylicious is written in pure Groovy, so delete the empty java folder in each of the sourceSets
sourceSets.each { sourceSet ->
    final javaDir = file("src/${sourceSet.name}/java/")
    javaDir.deleteDir()
}

repositories {
    maven {
        name = 'Modding Inquisition Snapshots'
        url = 'https://maven.moddinginquisition.org/snapshots'
    }
}

jarJar.enable()

final groovyLibs = [
        'stdlib', 'contracts', 'datetime',
        'nio', 'macro', 'macro-library',
        'templates', 'typecheckers'
]

dependencies {
    minecraft "net.minecraftforge:forge:${mc_version}-${forge_version}"

    groovyLibs.each {
        groovy groovyDep(it)
    }

    transformCompileOnly sourceSets.main.output

    testCompileOnly sourceSets.main.output
}

String groovyDep(String name) {
    return "org.apache.groovy:groovy${name == 'stdlib' ? '' : '-' + name}:$groovy_version"
}

tasks.withType(GroovyCompile).configureEach { GroovyCompile task ->
    task.groovyOptions.fork = true
    task.groovyOptions.encoding = 'UTF-8'
    task.groovyOptions.optimizationOptions.indy = true
}
compileGroovy.groovyOptions.optimizationOptions.groovydoc = true

license {
    header = rootProject.file('LICENSE')
}

final manifestAttr = [
       'FMLModType' : 'LIBRARY',
       'Implementation-Version': project.version
]

tasks.create('testJar', Jar) {
    group 'build'
    from sourceSets.test.output
    classifier 'test'
    manifest.attributes([
            'Specification-Title': 'no',
            'Specification-Vendor': 'Paint_Ninja',
            'Specification-Version': '1',
            'Implementation-Title': 'test',
            'Implementation-Version': '12.12',
            'Implementation-Vendor': 'Paint_Ninja',
            'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
    ])
}

tasks.create('groovyJar', ShadowJar) {
    group('build')
    archiveClassifier.set('groovy')
    configurations = [project.configurations.groovy]
    [
            '**/module-info.class',
            'LICENSE.txt',
            'LICENSE-junit.txt',
            'META-INF/LICENSE.txt',
            'META-INF/LICENSE.md',
            'META-INF/NOTICE.txt',
            '**/*.kotlin-module'
    ].each { exclude it }
    manifest.attributes(manifestAttr + ['Automatic-Module-Name': 'com.matyrobbrt.gml.groovy'])
    transform(UpdatedGroovyExtensionModuleTransformer)
    mergeServiceFiles()
}

tasks.create('fullJar', Jar) {
    from sourceSets.main.output
    from sourceSets.transform.output
    manifest.attributes(manifestAttr + [
            'Automatic-Module-Name': 'com.matyrobbrt.gml', 'FMLModType': 'LANGPROVIDER'
    ])
    archiveClassifier.set 'full'
    group 'build'
    dependsOn(groovyJar)
    from(groovyJar.archiveFile.get().asFile) {
        into 'META-INF/jarjar'
        rename groovyJar.archiveName as String, 'groovy.jar'
    }
    final path = project.file("$buildDir/jarjar/metadata.json")
    doFirst {
        makeJarJar(path)
    }
    from(path) {
        into 'META-INF/jarjar'
    }
}

private void makeJarJar(File path) {
    final groovy = JiJUtils.makeJarJson('com.matyrobbrt.gml', 'groovy-homebaked', project.groovy_version, 'groovy.jar')
    JiJUtils.writeJiJ(path, groovy)
}